-- 프로시저를 통해 사원본호를 입력하면 사원이름/사원월급/사원직책 매개변수를 통해 전달. --

CREATE OR REPLACE PROCEDURE EMP_PROCEDURE_OUTMODE
(
    VEMPNO IN EMPLOYEES.EMPLOYEE_ID%TYPE,
    VNAME OUT EMPLOYEES.FIRST_NAME%TYPE,
    VSALARY OUT EMPLOYEES.SALARY%TYPE,
    VJOBID OUT EMPLOYEES.JOB_ID%TYPE
)
IS
    -- 지역 변수. --

BEGIN
    --SELECT FIRST_NAME, SALARY, JOB_ID FROM EMPLOYEES WHERE EMPLOYEE_ID=100;
    SELECT FIRST_NAME, SALARY, JOB_ID INTO VNAME, VSALARY, VJOBID FROM EMPLOYEES WHERE EMPLOYEE_ID=VEMPNO;

--EXCEPTION

END;
/

-- EXCE를 사용하면 값을 입력하는게 불가함.

DECLARE
    VEMP_ROWTYPE EMPLOYEES%ROWTYPE;

BEGIN
    -- 변수명은 달라도 되지만, 타입은 항상 같게 해야 함.
    EMP_PROCEDURE_OUTMODE(100,
    VEMP_ROWTYPE.FIRST_NAME,
    VEMP_ROWTYPE.SALARY,
    VEMP_ROWTYPE.JOB_ID
    );
    
    DBMS_OUTPUT.PUT_LINE('이름 : '||VEMP_ROWTYPE.FIRST_NAME);
    DBMS_OUTPUT.PUT_LINE('봉급 : '||VEMP_ROWTYPE.SALARY);
    DBMS_OUTPUT.PUT_LINE('직책 : '||VEMP_ROWTYPE.JOB_ID);

END;
/

-- 프로시저를 워크시트 밖에서 불러 사용.
VARIABLE VNAME VARCHAR2(100)
VARIABLE VSALARY NUMBER
VARIABLE VJOBID VARCHAR2(10)

EXECUTE EMP_PROCEDURE_OUTMODE(200, :VNAME, :VSALARY, :VJOBID);

PRINT VNAME;
PRINT VSALARY;
PRINT VJOBID;

-- PROCEDURE IN/OUT MODE 동시 사용.
CREATE OR REPLACE PROCEDURE PROCEDURE_INOUTMODE(VSALARY IN OUT VARCHAR2)

IS

BEGIN
    VSALARY := TO_CHAR(VSALARY, '$999999999');
    VSALARY := '$'||SUBSTR(VSALARY, -9, 3)||','||SUBSTR(VSALARY, -6, 3)||','||SUBSTR(VSALARY, -3, 3);

END;
/

DECLARE
    VSALARY VARCHAR(20) := '123456789';

BEGIN
    PROCEDURE_INOUTMODE(VSALARY);
    DBMS_OUTPUT.PUT_LINE('VSALARY = '||VSALARY);
END;
/

-- 트리거 테스팅. --
DROP TABLE EMP01;
-- EMP01 만든 후, 트리거 생성. 입력될 때마다 입력값 출력해주는 트리거.
CREATE TABLE EMP01
(
    EMPNO NUMBER(4) PRIMARY KEY,
    ENAME VARCHAR(20),
    JOB VARCHAR2(50)
);

desc emp01;

CREATE OR REPLACE TRIGGER EMP01_TRIGGER
    AFTER INSERT ON EMP01
    FOR EACH ROW
    
BEGIN
    DBMS_OUTPUT.PUT_LINE(:NEW.EMPNO||', '||:NEW.ENAME||', '||'신입사원이 입사하였습니다.');

END;
/

INSERT INTO EMP01 VALUES((SELECT NVL(MAX(EMPNO), 0)+1 FROM EMP01), DBMS_RANDOM.STRING('U', 4), 'IT_DEV');

SELECT * FROM EMP01;

CREATE TABLE SAL01
(
    SALNO NUMBER(4),
    SALARY NUMBER,
    EMPNO NUMBER(4)    
);

alter table SAL01 add constraints SAL01_SALNO_pk primary key(SALNO);
alter table SAL01 add constraints SAL01_EMPNO_fk foreign key(EMPNO) REFERENCES EMP01(EMPNO);

SELECT * FROM USER_CONS_COLUMNS WHERE TABLE_NAME='SAL01';

CREATE SEQUENCE SAL01_SEQ
START WITH 1
INCREMENT BY 1
MINVALUE 1
MAXVALUE 100000
NOCYCLE
CACHE 2;

-- 입력하면 저장이 되어야 하니까, 트리거 생성. --
CREATE OR REPLACE TRIGGER EMP01_TRRIGER2
AFTER INSERT ON EMP01
FOR EACH ROW
BEGIN
                            /* 시퀀스를 사용하기 싫다면, 아래방법으로. */
    -- INSERT INTO SAL01 VALUE((SELECT NVL(MAX(EMPNO), 0)+1 FROM SAL01));
    INSERT INTO SAL01 VALUES(SAL01_SEQ.NEXTVAL, 100000, :NEW.EMPNO);
    DBMS_OUTPUT.PUT_LINE(:NEW.EMPNO||'번호 사원이 성공적으로 입력되었습니다.');
END;
/

INSERT INTO EMP01 VALUES((SELECT NVL(MAX(EMPNO), 0)+1 FROM EMP01), DBMS_RANDOM.STRING('U', 4), 'IT_DEV');

SELECT * FROM SAL01;
SELECT * FROM EMP01;

-- EMP01에서 사원의 정보를 제거했을 때, SAL01에 해당되는 사원도 함께 삭제되도록 프로그래밍. --
CREATE OR REPLACE TRIGGER EMP01_TRIGGER3
    AFTER DELETE ON EMP01
    FOR EACH ROW
BEGIN
    -- SAL에 해당되는 사원의 정보가 삭제돼야 함.
    DELETE FROM SAL01 WHERE EMPNO=OLD.EMPNO;
    DBMS_OUTPUT.PUT_LINE(:OLD.EMPNO||'가 SAL01에서 삭제 완료되었습니다.');

END;
/